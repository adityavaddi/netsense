package com.xeralux.device;
//import "nanopb.proto";

option java_package = "com.xeralux.device";

// This message is used by the client to upload sample data to the server.
// It is unacknowledged to save bandwidth.
message SensorSample {
	// sampleType is usually a single character string.
	required string sensor = 1;

	// Time is in microseonds since the Unix epoch.
	required uint64 time = 2;

	// Value is carried in a uint64, but encoding is application
	// specific. Could be fixed point, double, etc.
	required uint64 value = 3;

	// Units of measurement for calibrated sensors.
	optional string units = 4;
}

// Enumeration of the qualifier bits for LightingCtrl.
enum LightingCtrlQualifier {
	MotionSensor = 0;
	LightSensor = 1;
	NoNetwork = 2;
	RemoteMotion = 3;
	RemoteLightSensor = 4;

	// This bit will never be set on the micronode.
	// For the time after a "Disqualified" event, the
	// priority level of that event is ignored.
	Disqualified = 7;
}

// Lighting control message. This message is used standalone to override
// the light state. It is also used as a field in other lighting oriented
// messages.
message LightingCtrl {
	// Priority: when multiple entities request a change to the
	// lighting state, the lowest priority number wins. In case of a tie,
	// outcome is undefined.
	required uint32 pri = 1;

	// Mask of which channels to modify. Up to 32 channels can be specified.
	required uint32 mask = 2;

	// One byte for each channel. If bit N is set in mask
	// and this array is shorter than N, 0 is assumed.
	required bytes level = 3;

	// Bitmask for qualifiers. If a bit is set, the
	// corresponding qualifying condition must be active
	// for this state to apply.
	optional uint32 qualifiers = 4;
}

// Message to describe an event in time, with recurrence based on
// weekday, day of month, month of year, and/or year.
// There are 2 parts to the message: a time of day component
// and a day filter component. If the day filters are not present
// they are assumed to be all-ones.
message CalendarEvent {
	// Seconds after the minute.
	required uint32 sec = 1;

	// Minutes after the hour.
	required uint32 min = 2;

	// Hours after midnight.
	required uint32 hr = 3;

	// 7-bit mask for days of the week.
	optional uint32 wday = 4;

	// 31-bit mask for day of the month.
	optional uint32 mday = 5;

	// 12-bit mask for month of the year.
	optional uint32 mon = 6;

	// 16-bit mask for the year. Year bit number is computed as 1<<(year%16)
	optional uint32 year = 7;
}

// Types of lighting override.
enum LightingForceType {
	// Override state is stored in the flash and persists across
	// reboots. Useful for forcing the light to a particular state.
	Persistent = 1;

	// Only override until next reboot. Useful for performing
	// closed-loop control over the network. Will not wear/tear
	// on the flash.
	Volatile = 2;
}

// Force the lights to a certain state (override mode).
message LightingForceState {
	required LightingCtrl state = 1;

	// Default is "Persistent" if not specified.
	optional LightingForceType ftype = 2;
}

// Revert override modes and resume autonomous operation.
message LightingSetAuto {
}

// Clear the lighting schedule
message LightingClearSchedule {
}

// Describes a wall-clock scheduled lighting control change.
message LightingScheduledEvent {
	// Id number. Each schedule entry is assumed to have a
	// unique id. This id can be used to delete the scheduled
	// change after it has been scheduled.
	required uint32 id = 1;

	// When to apply the state change.
	required CalendarEvent event = 2;

	// What to apply.
	required LightingCtrl state = 3;
}

// Type of alarm.
enum AlarmType {
	// 300: Alarms synthesized by the server.
	CommFail = 300;
	SimFail = 301; // software simulator generated
	NotTested = 302; // Client has not run a mfg test yet
	DownrevSoftware = 303; // The device is running an old software load
	BadSensorData = 304;  // The server is receiving bad data from a sensor
	ConfigFail = 305; // The device is misconfigured or partially configured
	DegradedNetwork = 306; // Low RSSI or SNR
	SoftwareUpdateFail = 307;
	ScheduleFail = 308;
	PreRuninFail = 309;
	PostRuninFail = 310;

	// 200: Alarms that are generated by the uNode.
	USPFail = 200; // The USP board has failed
	PMACFail = 201;
	DriverFail = 202; // Deprecated
	FarmUSPFail = 203; // The farm USP board (CO2 sensor) has failed.
	SensorFail = 204; // The sensor board seems to be missing
	StrangeReboot = 205;  // The uNode rebooted unexpectedly.
	Assert = 206; //Something happened that never should
	X509ClientFail = 207;  // Didn't connect with the expected credentials
	X509ServerFail = 208;  // Didn't connect with the expected credentials
	UnderPower = 209;
	OverPower = 210;

	// 220-2xx: HW-specific alarms generated by the uNode.
	// There is no significance between the name or model number of the
	// thing that failed and the alarm number.
	// HWFail_generic is for components that don't have their own code yet.
	HWFail_generic = 220;
	HWFail_HIH6131 = 221;
	HWFail_ISL29023 = 222;
	HWFail_SE95 = 223;
	HWFail_ZMotion = 224;
	HWFail_MMA8451 = 225;
	HWFail_TSC3414 = 226;
	HWFail_UrbanUSP = 227;
//	HWFail_USP_Std = 227;  // Can't talk to standard USP.
//	HWFail_USP_Farm = 228;  // Can't talk to "farm" USP.
	HWFail_RTC = 229;
	HWFail_EEPROM = 230;
	HWFail_NIGHTHAWK = 231;
	SWUpdateFail_SENSORPOD = 232;
    HWFail_STUCK_RELAY = 233;
    HWFail_PCT2075  = 223;
    HWFAIL_SIHAWK = 234;
    Epic_Fail = 31337;
}

// Severity of alarm.
enum AlarmSeverity {
	// No alarm.
	Clear = 0;

	// Failure imminent.
	// (e.g. LED aging)
	Warning = 1;

	// Failed, but still partially functional.
	// (e.g. thermal foldback).
	Minor = 2;

	// Failed, not working, service required.
	// (e.g. USPFail).
	Major = 3;

	// Service required NOW.
	// (e.g. CommFail, DriverFail)
	Critical = 4;
}

// Alarm generated from the device.
message DeviceAlarm {
	required AlarmType alarmType = 1;

	required AlarmSeverity alarmSeverity = 2;

	// String message to attach to alarm. May contain details
	// about failed parameter, estimated time to failure, etc.
	optional string msg = 3;
}

// Enum of miscellaneous device actions.
enum ActionType {
	// Perform a device reset immediately.
	ColdReset = 0;

	// Erase xapp, xprov0, and xprov1 configstores; then perform device
	// reset.
	// WARNING: xapp stores the default network connection profiles.
	// Erasing these will restore the factory defaults.  Ensure your
	// local installation can provide connections to nodes holding
	// factory-shipped connection profiles, or you will lose contact
	// with your nodes after ResetFactory has been applied.
	ResetFactory = 1;

	// Erase xprov0 and xprov1 configstores; then perform device reset.
	ResetProvisioning = 2;

	// Flip FW partition without an OTA (rolls back without download).
	// Then performs a device reset.
	ChangeFWPartition = 3;
}

// Message to request device action.
message DeviceActionReq {
	required ActionType actionType = 1;
}

// KR Note: astronomical stuff not implemented on unode, and may not ever be.
// Do not use this stuff for now.

enum AstronomicalBody {
	Sun = 1;
	// Moon is not implemented.
	Moon = 2;
}

enum AstronomicalEventType {
	Rise = 1;
	Set = 2;
	// Noon is not implemented.
	Noon = 3;
}

enum AstronomicalEventZenith {
	Official = 1;
	Civil = 2;
	Nautical = 3;
	Astronomical = 4;
}

message AstronomicalEvent {
	// Sun or moon.
	required AstronomicalBody body = 1;

	// Rise or set. ('type' is a reserved word in scala)
	required AstronomicalEventType atype = 2;

	// Definition of rise or set.
	required AstronomicalEventZenith zenith = 3;

	// 7-bit mask for days of the week.
	optional uint32 wday = 4;

	// 31-bit mask for day of the month.
	optional uint32 mday = 5;

	// 12-bit mask for month of the year.
	optional uint32 mon = 6;

	// 16-bit mask for the year. Year bit number is computed as 1<<(year%16)
	optional uint32 year = 7;
}

message LightingAstronomicalEvent {
	// Id number. Each schedule entry is assumed to have a
	// unique id. This id can be used to delete the scheduled
	// change after it has been scheduled.
	required uint32 id = 1;

	// When to apply the state change.
	required AstronomicalEvent event = 2;

	// What to apply.
	required LightingCtrl state = 3;
}

// This message is used by the server to request the device send a
// SensorSample.
message SensorSampleReq {
	// sampleType is usually a single character string.
	required string sensor = 1;
}

enum WiFiAuthType {
	Other = 0;
	Open = 1;
	WEP = 2;
	WPA2_PSK = 3;
	WPA2_EAP_TLS = 4;
}