 @startuml

group LSS + STS Flow
Node -> MQTT: Device sends \nloginRequest
MQTT -> Bridge: Bridge drains\nLoginRequest\nv1/<nodeid>/out/\nPOST/loginReq
Bridge -> Kafka: Bridge publishes \nthe events to\n Login \nTopic(login$suffix)
Kafka -> DeviceService: Device Service consumes\n LoginRequest
                   activate DeviceService
DeviceService -> Kafka:Sends \nauto-commissioning\n request to Datadealer\n(dd.capeworker.in$suffix)
                   activate DeviceService#FFBBBB
                   deactivate DeviceService

Kafka -> DataDealer: Consumes Auto-commissioning \nrequest[CASEL]
                   activate DataDealer
DataDealer --> DataDealer: Check if node exists
                   activate DataDealer #FFBBBB
database Neo4j
database Cassandra

DataDealer -> Neo4j: Check node \norg hierarchy
Neo4j --> DataDealer: Org Hierarchy of node
                   deactivate DataDealer #FFBBBB
rnote over DataDealer
Use **default** scheduleid
 for new node
endrnote
DataDealer -> Neo4j: Create empty node \nif newly created node\nelse update props
                   deactivate DataDealer
                   activate DeviceService#FFBBBB
DeviceService -> DeviceService: Filters nodes\n with model "cnext"
DeviceService -> Kafka: Sends LoginRequest to\n Schedule Service\n (schedule.loginreq$suffix)
                   deactivate DeviceService
                   deactivate DeviceService

Kafka -> ScheduleService :  Consumes LoginRequest [RestPack]
                   activate ScheduleService

ScheduleService -> ScheduleService :  Check Node org\n hierarchy for site
                   activate ScheduleService#FFBBBB
ScheduleService -> Neo4j :  Get Node site scheduleId lat lon
Neo4j --> ScheduleService :  Node Data w/ associated scheduleId\n siteId location data
ScheduleService -> ScheduleService :  Use **default** scheduleid \nand **Unknown** siteid\n if node not exists
                   deactivate ScheduleService

ScheduleService -> ScheduleService :  Get ScheduleData \nto be send to node
                   activate ScheduleService#FFBBBB
ScheduleService -> Neo4j:  Get scheduleData from Neo4j
Neo4j --> ScheduleService :  ScheduleData [Network Events[Days Actions]]
                   deactivate ScheduleService

rnote over ScheduleService
 Calculate Slots and
 DayLight Savings(DST)
endrnote
ScheduleService -> ScheduleService: Send calculated SlotActions to STS
                   activate ScheduleService#FFBBBB
ScheduleService -> Kafka: Send [Normal + NoNetwork] SlotActions\n to Schedule Transformer Service(**STS**)\n(schedule.commands$suffix)
ScheduleService --> Neo4j: Log **last_delivered** timestamp to Schedule
                   deactivate ScheduleService

ScheduleService -> ScheduleService: LSS after sending schedule\nshould set the light to\n the last manual override \nif exists
                   activate ScheduleService#FFBBBB
ScheduleService -> Cassandra: Get Light Status from **Light**
Cassandra --> ScheduleService: Async Result LightStatus \n<<driver isscheduled startdt..>>
ScheduleService -> ScheduleService: Calculate timeout && if scheduled

' Activating LFS
                   activate ScheduleService#CornSilk
ScheduleService -> ScheduleService: Send **LightingForceState** \nif timeout = (currentdt - startdt) > 0\n isscheduled false
ScheduleService --> Kafka: **LightingForceState** command send to\n node (light.command?suffix)

' Registering timer
                   activate ScheduleService#FFBBBB
ScheduleService --> ScheduleService:  Register for cancellable \noverride timer(Internal FSM timer)
rnote over ScheduleService
isscheduled: false
policy: override
startdt: currenttime - startdt
pri: 3
endrnote
||35||
ScheduleService --> Cassandra: Update Light table
ScheduleService --> Kafka: **LightingSetAuto** command send to node on timer expiry
                   deactivate ScheduleService
                   deactivate ScheduleService

'note right : For manual override nodes,\n**LightingSetAuto** should be \nsent after the timer timeout
rnote over ScheduleService
For commissioned nodes,
**LightingSetAuto** should be
sent after the timer timeout
endrnote
rnote over ScheduleService
isscheduled: true
policy: scheduled
startdt: null
pri: 7
schedule_id: scheduleId
schedule_time: scheduleTime
endrnote
ScheduleService --> Cassandra: Update Light table
                   deactivate ScheduleService
                   deactivate ScheduleService
||30||
                   activate ScheduleTransform#FFBBBB
Kafka -> ScheduleTransform: Consumes STS event from Kafka
Kafka -> ScheduleTransform: Consumes Light commands from Kafka
ScheduleTransform -> ScheduleTransform: Transforms Actions/Commands into \ndevice specific ctrl messages
                   activate ScheduleTransform#FFBBBB
ScheduleTransform -> ScheduleTransform: Check if timeout = (currentdt - startdt) > 0 \n send override if exists
ScheduleTransform -> Cassandra: Get **Light** for nodeid
Cassandra --> ScheduleTransform: isscheduled, startdt
                   deactivate ScheduleTransform#FFBBBB
rnote over ScheduleTransform
STS will have
all the slot array
in a single aio message
endrnote
group Schedule Commands
ScheduleTransform --> MQTT: Schedule **aio** command send to node v1/<nodeid>/in/PUT/light/schedule/aio
ScheduleTransform --> MQTT: **LightingForceState** command send to node(**if** manual override is **active**)
end
                   deactivate ScheduleTransform

MQTT --> Node: Device consumes \n commands
end
@enduml