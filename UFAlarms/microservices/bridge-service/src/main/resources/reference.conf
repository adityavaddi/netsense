
bridge {
  bridge.type = "withmqtt"
  bridge.type = ${?bridge_type}
  log.info.rate = 100
  log.info.rate = ${?log_info_rate}
  tomqtt.msg.expirytime.insec = 60
  tomqtt.msg.expirytime.insec = ${?tomqtt_msg.expirytime_insec}
  from.mapping.key = "sensor"//""sensor"//to kafka
  to.mapping.key = "none"
  from.mapping.key = ${?bridge_from_mapping}//""sensor"//to kafka
  to.mapping.key = ${?bridge_to_mapping}
  toKafka {
    kafka.topic = "node.events"
    kafka.topic = ${?tokafka_topic}
    //    mapping.key = ${?TOKAFKA_MAPPING_KEY}
  }

  fromMqttToKafka {
    topic-mappings = [
      {
        kafka.topic = config.reply${?env_suffix}
        mqtt.topic = "v1/+/out/+/+/+/config/#"
        mqtt.topic = ${?from_mqtt_to_kafka_config}
      },
      {
        kafka.topic = config.reply${?env_suffix}
        mqtt.topic = "v1/+/out/+/+/+/vpn/#"
        mqtt.topic = ${?from_mqtt_to_kafka_config_vpn}
      },
      {
        kafka.topic = sensor${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/sensors/#"
        mqtt.topic = ${?from_mqtt_to_kafka_sensor}
      },
      {
        kafka.topic = login${?env_suffix}
        mqtt.topic = "v1/+/out/POST/loginReq/#"
        mqtt.topic = ${?from_mqtt_to_kafka_device}
      },
      {
        kafka.topic = alarm${?env_suffix}
        mqtt.topic = "v1/+/out/+/alarm/#"
        mqtt.topic = ${?from_mqtt_to_kafka_alarm}
      },
      {
        kafka.topic = media${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/mediaserver/#"
        mqtt.topic = ${?from_mqtt_to_kafka_media}
      },
      {
        kafka.topic = login${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/lwt/#"
        mqtt.topic = ${?from_mqtt_to_kafka_lwt}
      },
      {
        kafka.topic = ota${?env_suffix}
        mqtt.topic = "v1/+/out/EXEC/REPLY/+/ota/#"
        mqtt.topic = ${?from_mqtt_to_kafka_ota_reply}
      },
      {
        kafka.topic = ota${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/ota/#"
        mqtt.topic = ${?from_mqtt_to_kafka_ota_unsol}
      },
      {
        kafka.topic = sensor${?env_suffix}
        mqtt.topic = "v1/+/out/GET/REPLY/+/sensors/#"
        mqtt.topic = ${?from_mqtt_to_kafka_sensor_reply}
      },
      {
        kafka.topic = va.node.evt${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/evt/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_evt}
      },
      {
        kafka.topic = va.node.cfg${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/cfg/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_cfg}
      },
      {
        kafka.topic = traffic.evt.linec${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/evt/linec/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_linec}
      },
      {
        kafka.topic = traffic.evt.objent${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/evt/objent/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_objent}
      },
      {
        kafka.topic = traffic.evt.objlev${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/evt/objlev/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_objlev}
      },
      {
        kafka.topic = traffic.evt.objdwl${?env_suffix}
        mqtt.topic = "v1/+/out/va-v1/evt/objdwl/#"
        mqtt.topic = ${?from_mqtt_to_kafka_va_objdwl}
      },
      {
        kafka.topic = node.gps${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/gps/#"
        mqtt.topic = ${?from_mqtt_to_kafka_gps_unsol}
      },
      {
        kafka.topic = node.systeminfo${?env_suffix}
        mqtt.topic = "v1/+/out/UNSOL/event/system_info/Update"
        mqtt.topic = ${?from_mqtt_to_kafka_node_systeminfo}
      }
//      {
//        kafka.topic = ppv.node.evt${?env_suffix}
//        mqtt.topic = "v1/+/out/va-v1/evt/pko/#"
//        mqtt.topic = ${?from_mqtt_to_kafka_parking_ppv_evt}
//      }
//      {
//        kafka.topic = ppv.node.cfg${?env_suffix}
//        mqtt.topic = "v1/+/out/va-v1/cfg/pko/#"
//        mqtt.topic = ${?from_mqtt_to_kafka_parking_ppv_cfg}
//      }
    ]
  }

  fromKafka {
    kafka.topic = "corenode.command"
    kafka.consumer.group = "commands.client.group"
    kafka.topic = ${?fromkafka_topic}
    kafka.consumer.group = ${?fromkafka_consumer_group}
  }
  toRabbit {
    rabbitmq.exchange = "node.commands"
    rabbitmq.routing = "*"
    rabbitmq.exchange = ${?fromkafka_exchange}
    rabbitmq.routing = ${?fromkafka_routing}
  }
  fromRabbit {
    async.parallelism = 2000
    async.parallelism = ${?rabbit_consumer_async_parallelism}
    prefetch.count = 600
    prefetch.count = ${?rabbit_consumer_prefetch_count}
    rabbitmq.exchange = "node.events"
    rabbitmq.routing = "*.alarm.*,*.sensor.*,*.gps.*"
    rabbitmq.queue = "bridge"
    rabbitmq.exchange = ${?tokafka_exchange}
    rabbitmq.routing = ${?tokafka_routing}
    rabbitmq.queue = ${?tokafka_queue}
    topic-mappings = [
      {
        kafka.topic = "corenode.sensor"${?env_suffix}
        rabbitmq.msg.type = "sensor"
      },
      {
        kafka.topic = "corenode.alarm"${?env_suffix}
        rabbitmq.msg.type = "alarm"
      },

      {
        kafka.topic = "corenode.gps"${?env_suffix}
        rabbitmq.msg.type = "gps"
      }

    ]
  }
}


akka {

  loglevel = "DEBUG"
  log-dead-letters = 10
  log-dead-letters-during-shutdown = on
  logger-startup-timeout = 30s

  jvm-exit-on-fatal-error = true
  stdout-loglevel = "DEBUG"

}

metrics {
  prefix = "bridge-service"
  prefix = ${?metrics_prefix}
}