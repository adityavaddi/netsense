package com.xeralux.device;
//import "nanopb.proto";

option java_package = "com.xeralux.device";

// This message is used by the client to upload sample data to the server.
// It is unacknowledged to save bandwidth.
message SensorSample {
	// sampleType is usually a single character string.
	required string sensor = 1;

	// Time is in microseonds since the Unix epoch.
	required uint64 time = 2;

	// Value is carried in a uint64, but encoding is application
	// specific. Could be fixed point, double, etc.
	required uint64 value = 3;

	// Units of measurement for calibrated sensors.
	optional string units = 4;
}

// Enumeration of the qualifier bits for LightingCtrl.
enum LightingCtrlQualifier {
	MotionSensor = 0;
	LightSensor = 1;
	NoNetwork = 2;
	RemoteMotion = 3;
	RemoteLightSensor = 4;

	// This bit will never be set on the micronode.
	// For the time after a "Disqualified" event, the
	// priority level of that event is ignored.
	Disqualified = 7;
}

// Lighting control message. This message is used standalone to override
// the light state. It is also used as a field in other lighting oriented
// messages.
message LightingCtrl {
	// Priority: when multiple entities request a change to the
	// lighting state, the lowest priority number wins. In case of a tie,
	// outcome is undefined.
	required uint32 pri = 1;

	// Mask of which channels to modify. Up to 32 channels can be specified.
	required uint32 mask = 2;

	// One byte for each channel. If bit N is set in mask
	// and this array is shorter than N, 0 is assumed.
	required bytes level = 3;

	// Bitmask for qualifiers. If a bit is set, the
	// corresponding qualifying condition must be active
	// for this state to apply.
	optional uint32 qualifiers = 4;
}

// Message to describe an event in time, with recurrence based on
// weekday, day of month, month of year, and/or year.
// There are 2 parts to the message: a time of day component
// and a day filter component. If the day filters are not present
// they are assumed to be all-ones.
message CalendarEvent {
	// Seconds after the minute.
	required uint32 sec = 1;

	// Minutes after the hour.
	required uint32 min = 2;

	// Hours after midnight.
	required uint32 hr = 3;

	// 7-bit mask for days of the week.
	optional uint32 wday = 4;

	// 31-bit mask for day of the month.
	optional uint32 mday = 5;

	// 12-bit mask for month of the year.
	optional uint32 mon = 6;

	// 16-bit mask for the year. Year bit number is computed as 1<<(year%16)
	optional uint32 year = 7;
}

// Types of lighting override.
enum LightingForceType {
	// Override state is stored in the flash and persists across
	// reboots. Useful for forcing the light to a particular state.
	Persistent = 1;

	// Only override until next reboot. Useful for performing
	// closed-loop control over the network. Will not wear/tear
	// on the flash.
	Volatile = 2;
}

// Force the lights to a certain state (override mode).
message LightingForceState {
	required LightingCtrl state = 1;

	// Default is "Persistent" if not specified.
	optional LightingForceType ftype = 2;
}

// Revert override modes and resume autonomous operation.
message LightingSetAuto {
}

// Clear the lighting schedule
message LightingClearSchedule {
}

// Describes a wall-clock scheduled lighting control change.
message LightingScheduledEvent {
	// Id number. Each schedule entry is assumed to have a
	// unique id. This id can be used to delete the scheduled
	// change after it has been scheduled.
	required uint32 id = 1;

	// When to apply the state change.
	required CalendarEvent event = 2;

	// What to apply.
	required LightingCtrl state = 3;
}

// Type of alarm.
enum AlarmType {
	// 300: Alarms synthesized by the server.
	CommFail = 300;
	SimFail = 301; // software simulator generated
	NotTested = 302; // Client has not run a mfg test yet
	DownrevSoftware = 303; // The device is running an old software load
	BadSensorData = 304;  // The server is receiving bad data from a sensor
	ConfigFail = 305; // The device is misconfigured or partially configured
	DegradedNetwork = 306; // Low RSSI or SNR
	SoftwareUpdateFail = 307;
	ScheduleFail = 308;
	PreRuninFail = 309;
	PostRuninFail = 310;

	// 200: Alarms that are generated by the uNode.
	USPFail = 200; // The USP board has failed
	PMACFail = 201;
	DriverFail = 202; // Deprecated
	FarmUSPFail = 203; // The farm USP board (CO2 sensor) has failed.
	SensorFail = 204; // The sensor board seems to be missing
	StrangeReboot = 205;  // The uNode rebooted unexpectedly.
	Assert = 206; //Something happened that never should
	X509ClientFail = 207;  // Didn't connect with the expected credentials
	X509ServerFail = 208;  // Didn't connect with the expected credentials
	UnderPower = 209;
	OverPower = 210;
    HardFault = 211;
	// 220-2xx: HW-specific alarms generated by the uNode.
	// There is no significance between the name or model number of the
	// thing that failed and the alarm number.
	// HWFail_generic is for components that don't have their own code yet.
	HWFail_generic = 220;
	HWFail_HIH6131 = 221;
	HWFail_ISL29023 = 222;
	HWFail_SE95 = 223;
	HWFail_ZMotion = 224;
	HWFail_MMA8451 = 225;
	HWFail_TSC3414 = 226;
	HWFail_UrbanUSP = 227;
//	HWFail_USP_Std = 227;  // Can't talk to standard USP.
//	HWFail_USP_Farm = 228;  // Can't talk to "farm" USP.
	HWFail_RTC = 229;
	HWFail_EEPROM = 230;
	HWFail_NIGHTHAWK = 231;
	SWUpdateFail_SENSORPOD = 232;
    HWFail_STUCK_RELAY = 233;
    HWFail_PCT2075  = 223;
    HWFAIL_SIHAWK = 234;
    HWFAIL_GPS = 235;
    HWFail_PodBus = 236;
    Epic_Fail = 31337;
}

// Severity of alarm.
enum AlarmSeverity {
	// No alarm.
	Clear = 0;

	// Failure imminent.
	// (e.g. LED aging)
	Warning = 1;

	// Failed, but still partially functional.
	// (e.g. thermal foldback).
	Minor = 2;

	// Failed, not working, service required.
	// (e.g. USPFail).
	Major = 3;

	// Service required NOW.
	// (e.g. CommFail, DriverFail)
	Critical = 4;
}

// Alarm generated from the device.
message DeviceAlarm {
	required AlarmType alarmType = 1;

	required AlarmSeverity alarmSeverity = 2;

	// String message to attach to alarm. May contain details
	// about failed parameter, estimated time to failure, etc.
	optional string msg = 3;
}

// Enum of miscellaneous device actions.
enum ActionType {
	// Perform a device reset immediately.
	ColdReset = 0;

	// Erase xapp, xprov0, and xprov1 configstores; then perform device
	// reset.
	// WARNING: xapp stores the default network connection profiles.
	// Erasing these will restore the factory defaults.  Ensure your
	// local installation can provide connections to nodes holding
	// factory-shipped connection profiles, or you will lose contact
	// with your nodes after ResetFactory has been applied.
	ResetFactory = 1;

	// Erase xprov0 and xprov1 configstores; then perform device reset.
	ResetProvisioning = 2;

	// Flip FW partition without an OTA (rolls back without download).
	// Then performs a device reset.
	ChangeFWPartition = 3;
}

// Message to request device action.
message DeviceActionReq {
	required ActionType actionType = 1;
}

// KR Note: astronomical stuff not implemented on unode, and may not ever be.
// Do not use this stuff for now.

enum AstronomicalBody {
	Sun = 1;
	// Moon is not implemented.
	Moon = 2;
}

enum AstronomicalEventType {
	Rise = 1;
	Set = 2;
	// Noon is not implemented.
	Noon = 3;
}

enum AstronomicalEventZenith {
	Official = 1;
	Civil = 2;
	Nautical = 3;
	Astronomical = 4;
}

message AstronomicalEvent {
	// Sun or moon.
	required AstronomicalBody body = 1;

	// Rise or set. ('type' is a reserved word in scala)
	required AstronomicalEventType atype = 2;

	// Definition of rise or set.
	required AstronomicalEventZenith zenith = 3;

	// 7-bit mask for days of the week.
	optional uint32 wday = 4;

	// 31-bit mask for day of the month.
	optional uint32 mday = 5;

	// 12-bit mask for month of the year.
	optional uint32 mon = 6;

	// 16-bit mask for the year. Year bit number is computed as 1<<(year%16)
	optional uint32 year = 7;
}

message LightingAstronomicalEvent {
	// Id number. Each schedule entry is assumed to have a
	// unique id. This id can be used to delete the scheduled
	// change after it has been scheduled.
	required uint32 id = 1;

	// When to apply the state change.
	required AstronomicalEvent event = 2;

	// What to apply.
	required LightingCtrl state = 3;
}

// This message is used by the server to request the device send a
// SensorSample.
message SensorSampleReq {
	// sampleType is usually a single character string.
	required string sensor = 1;
}

enum WiFiAuthType {
	Other = 0;
	Open = 1;
	WEP = 2;
	WPA2_PSK = 3;
	WPA2_EAP_TLS = 4;
}

// This message is used by the node to upload GPS data to the server.  This data
// consists of latitude, longitude, altitude, and other GPS data packed into
// 32-bit and 64-bit integers.  The underlying GPS data from the device is
// output in an NMEA 0183 format and converted to this message format by the
// node firmware.
message GpsSample {
	// The GPS version field is here in case the type of GPS device or data
	// encoding changes in the future. Initially only version 0 is defined.
	// If this field is not present in a message then version 0 is implied.
	optional uint32 gpsVer = 1;

	// Node time stamp of the GPS data in seconds since the Unix epoch.
	// This field is is not necessarily derived from the GPS data stream.
	optional fixed32 epochSecs = 2;

	// Latitude and longitude:
	//   Bits 63-32:  int32  Latitude , lsb = 0.0000001 degs.
	//   Bits 31-00:  int32  Longitude, lsb = 0.0000001 degs.
	// The range for longitude is -180.0000000 to 180.0000000 degrees.
	// The range for  latitude is  -90.0000000 to  90.0000000 degrees.
	// West longitudes and south latitudes are negative.
	optional fixed64 latAndLon = 3;

	// Altitude and receiver status:
	//   Bits 31-12:  int20  Altitude, lsb = 0.1 meters.
	//   Bits 11-07: uint05  Spare.
	//   Bits 06-00: char07  Nav receiver status (A=valid, V=warning).
	optional fixed32 altAndMisc = 4;

	// SNRs, DOPs, fix type, control mode, and number of satellites:
	//   Bits 63-44: uint20  SNRs (combined max, ave, and min SNRs).
	//   Bits 43-32: uint12  PDOP (position   dilution of precision).
	//   Bits 31-20: uint12  HDOP (horizontal dilution of precision).
	//   Bits 19-08: uint12  VDOP (vertical   dilution of precision).
	//   Bits 07-06: uint02  Fix type, 0=none, 1=none, 2=2d, 3=3d.
	//   Bits 05-05: uint01  Control mode, 0=off, 1=on
	//   Bits 04-00: uint05  Number of satellites being tracked.
	// The SNRs field is a 20-bit integer combining the max, ave, and min
	// SNRs of tracked satellite signals where each of the SNR values can
	// range from 0 through 99:
	//   SNRs = SNRmax*10000 + SNRave*100 + SNRmin
	// The lsb for the PDOP, HDOP, and VDOP factors is 0.01 (unitless).
	optional fixed64 snrAndMisc = 5;
}

// Enum of GPS actions.
enum GpsActionType {
	// Send n GPS samples where n is a non-negative integer specified in
	// iValue.  A value of 0 indicates to send the last sample.  A value
	// greater than 0 indicates to acquire and send n new samples.
	SendSample = 0;

	// Set the node's GPS control mode according to the value set in the
	// iValue parameter:
	//    0 = Off: GPS device is off and not being managed.
	//    1 = On : GPS device is being actively managed by firmware
	//             according to the current GPS operational schedule.
	SetCtlMode = 1;

	// Set the GPS operating schedule according to the sValue parameter.
	// Set the schedule to be non-volatile by setting the iValue parameter
	// to 1.  The schedule is defined by up to 4 semicolon separated
	// entries encoded in a string in the following format:
	//    <nsamp>;<entry0>;<entry1>;<entry2>
	// where <nsamp>> is the total number of samples to acquire and send
	// and <entryN> is of the form
	//    <offt>,<acqt>,<fixt>,<pint>,<pcnt>,<ccnt>
	// where each of the comma separated arguments is a 16-bit unsigned
	// hexadecimal integer with a range of 0-FFFF:
	//    <offt> = off time [min]
	//    <acqt> = acquisition time [min]
	//    <fixt> = fix timeout [min]
	//    <pint> = poll interval [s]
	//    <pcnt> = poll count
	//    <ccnt> = cycle count
	//
	// Example Schedule 1
	//    In this schedule, 10 samples are collected with a poll interval
	//    of 60 (3Bh) seconds.
	//       A;0,1,F,3B,C8,1
	//    The schedule is decoded as follows:
	//        A => Acquire and send 10 samples of GPS data
	//        0 => Device is turned off for 0 minutes
	//        1 => Device is allowed to acquire data for 1 minute
	//             without being monitored by the node firmware
	//        F => GPS fix is allowed to take as long as 15 mins
	//       3B => Poll interval is 60 secs
	//       C8 => Poll count is 200 samples per cycle
	//        1 => Execute this entry 1 time
	//
	// Example Schedule 2
	//    In this schedule, 20 samples are collected with the collection
	//    defined by two schedule entries.  The first 5 samples have a poll
	//    interval of 60 (3Ch) seconds.  The second 5 samples have a poll
	//    interval of 5 minutes (12Ch seconds).
	//       14;0,1,F,3C,5,1;0,0,F,12C,C8,1
	//
	SetOpSchedule = 2;

	// Get the GPS current or non-volatile operating schedule from the node.
	// The schedule type returned is determined by the value of iValue:
	//    iValue = 0 => Return the current operating schedule
	//    iValue = 1 => Return the non-volatile operating schedule
	// The schedule is returned in the GpsActionRsp message in the sValue
	// string in the same format used for the SetOpSchedule action.  The
	// iValue integer in the message indicates whether the returned schedule
	// the current schedule (0) or the non-volatile schedule (1).
	GetOpSchedule = 3;
}

// Message to request GPS related action.
message GpsActionReq {
	required GpsActionType actionType = 1;

	// Optional integer parameter
	optional int32  iValue = 2;

	// Optional string parameter
	optional string sValue = 3; //[(nanopb).max_size = 128];
}

// Message response to GPS action request.
message GpsActionRsp {
	required GpsActionType actionType = 1;

	// String parameter
	optional int32 iValue = 2;

	// String parameter
	optional string sValue = 3; //[(nanopb).max_size = 128];
}
